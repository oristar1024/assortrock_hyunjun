코드영역   -> 함수의 정의와 상수들이 존재하는 메모리영역
데이터영역 -> 
힙 영역    -> 
스택 영역  -> 

c++은 객체지향언어가 아니다. (객체지향, 절차지향 모두 가능 -> 멀티패러다임언어)

객체지향
1. 사용자 정의 자료형이 존재하며, 해당 사용자 정의 자료형이 상태와 행동을 모두 포함해야 한다. (상태 -> 멤버 변수, 행동 -> 멤버 함수) => 추상화 (추상적인 개념을 문법적으로 표현하는것)
2. 

멤버 바이트패딩 규칙
1. 멤버변수 중 가장 사이즈가 큰것을 찾는다
2. 미리 할당한 공간이 끝났을때 해당 자료형의 사이즈로 추가 할당한다.
3. 빈공간이 있더라도, 무조건 연속으로 채우는 것이 아니라 자료형의 기준으로 칸을 만들어 생각한다
ex) char 기준 [a][b][][][c][c][c][c] = int 기준 [a][c] 

멤버함수
기본 적으론 전역함수와 동일하지만 자기 클래스의 포인터(클래스* const this)를 기본적으로 가지고있다.
따로 this->변수로 호출하지 않아도 멤버변수를 호출할 수 있다.
ex) 멤버변수 hp -= damage == this->hp -= this->damage

이름규칙 
1. 함수에 이름에는 인자의 자료형이 포함된다.
-> 이름은 같지만 인자가 다른 함수를 선언하는것을 함수 오버로딩이라고 한다.
2. 클래스는 이름에 포함된다.
-> myClass::Hp 와 Hp는 같지않다.
3. 지역은 이름에 포함된다.
-> 지역이 다르면 같은 이름의 변수를 선언 할 수 있다.
4. 리턴값은 이름에 포함되지 않는다.
-> void Func()과 int Func() 동시에 선언되지 않는다.

생성자 멤버 이니셜라이저 문법
myClass() : 멤버변수(초기값){}

함수에서 포인터를 리턴할땐 const를 붙여주자 (참조해서 수정 할 수 있기때문)




코드영역   -> 함수의 정의와 상수들이 존재하는 메모리영역
데이터영역 -> 전역변수, static변수
힙 영역    -> 동적할당
스택 영역  -> 지역변수

c++은 객체지향언어가 아니다. (객체지향, 절차지향 모두 가능 -> 멀티패러다임언어)

객체지향
1. 사용자 정의 자료형이 존재하며, 해당 사용자 정의 자료형이 상태와 행동을 모두 포함해야 한다. (상태 -> 멤버 변수, 행동 -> 멤버 함수) => 추상화 (추상적인 개념을 문법적으로 표현하는것)
2. 

멤버 바이트패딩 규칙
1. 멤버변수 중 가장 사이즈가 큰것을 찾는다
2. 미리 할당한 공간이 끝났을때 해당 자료형의 사이즈로 추가 할당한다.
3. 빈공간이 있더라도, 무조건 연속으로 채우는 것이 아니라 자료형의 기준으로 칸을 만들어 생각한다
ex) char 기준 [a][b][][][c][c][c][c] = int 기준 [a][c] 

멤버함수
기본 적으론 전역함수와 동일하지만 자기 클래스의 포인터(클래스* const this)를 기본적으로 가지고있다.
따로 this->변수로 호출하지 않아도 멤버변수를 호출할 수 있다.
ex) 멤버변수 hp -= damage == this->hp -= this->damage

이름규칙 
1. 함수에 이름에는 인자의 자료형이 포함된다.
-> 이름은 같지만 인자가 다른 함수를 선언하는것을 함수 오버로딩이라고 한다.
2. 클래스는 이름에 포함된다.
-> myClass::Hp 와 Hp는 같지않다.
3. 지역은 이름에 포함된다.
-> 지역이 다르면 같은 이름의 변수를 선언 할 수 있다.
4. 리턴값은 이름에 포함되지 않는다.
-> void Func()과 int Func() 동시에 선언되지 않는다.

생성자 멤버 이니셜라이저 문법
myClass() : 멤버변수(초기값){}

함수에서 포인터를 리턴할땐 const를 붙여주자 (참조해서 수정 할 수 있기때문)

Function const
멤버함수 뒤에 const를 붙여주면 함수 내부에서 객체의 상태변경이 불가능해진다.
-> 멤버함수의 기본인자인 this를 const로 만들어준다.
-> const Myclass* this의 역할을 한다. Myclass* const this는 기본적으로 this를 수정하는것이 불가능하기 때문에 const Myclass* const this와 같다.
-> 함수 내부에서 const가 아닌 멤버함수의 호출이 불가능하다.

static 멤버변수
클래스 내부의 전역변수를 만들 수 있다.(객체없이 호출이 가능하다)
ex) static int Count -> Myclass::Count
선언하고 따로 정의 해줘야한다. (const의 경우 클래스내부에서도 초기화가 가능하다.)
ex) static int Count -> int MyClass::a = 0;
멤버함수를 static으로 사용할때는, this를 인자로 넘겨주지 않는다.(객체없이 호출할 수 있기 때문)
따라서, 객체의 속성을 표현하기보단 해당 클래스 전체의 속성을 표현할 때 사용해야 한다.

static 지역변수
지역변수지만 데이터영역에 존재하고, 최초 한번만 메모리에할당되고 이후에는 기존값을 사용한다. (데이터 영역에 존재하므로 지역이 종료되어도 파괴되지않는다)
ex)
int PlayerID()
{
	static int id = 0; // 최초 호출때만 초기화된다.
	return ++id; // 호출될때마다 1씩 증가된 값을 리턴한다.
}

static 전역변수
선언된 소스파일 내에서만 사용 할 수 있다.

class MyClass; <- 클래스의 전방선언(헤더파일에 다른 클래스가 필요할때)
헤더파일에서 다른헤더를 #include하는것 왠만하면 하지말자.
-> cpp파일에선 맘대로해도된다.

extern < 변수의 전방선언(정의 따로)

#define a b
b의 내용을 그대로 a에 복사한다.

_CrtSetDbgFlag
crtdbg.h에 포함된 함수.
에러에 관련된 옵션들을 가지고 있고, 이들을 | 연산자를 통해 선택해서 설정 할 수 있다.
_CRTDBG_LEAK_CHECK_DF 옵션으로 메모리 누수를 체크 할 수 있다. (출력창에 나온다)
C++는 가비지컬렉터가 없기때문에 반드시 delete를 해줘야한다.
배열을 동적할당 했을 경우 delete[]로 삭제해야한다.

new int() // 로스트 포인터 (동적할당 해놓고 포인터를 연결해주지않았음)
이미 힙에 연결된 포인터에 새로 할당된 메모리를 연결하면, 기존메모리는 로스트포인터가 된다.
메모리누수의 원인.

반대의 경우 (힙 메모리는 삭제해놓고, 해당 위치를 가르키는 포인터가 남아있는 경우) 댕글링포인터 라고한다.
당연히 접근하려고하면 nullptr exception으로프로그램이 터진다.
따라서 힙메모리를 삭제했을 경우, 포인터도 nullptr로 만들어줘야한다.

int* a = new int(10);
delete a;
a = nullptr; 

| : bit or연산자. 옵션최적화를 위해 사용되는경우가 많다.
옵션최적화 예시, a b c는 각각 다른 옵션이다.
#define a 0x01
#define b 0x02
#define c 0x04
void Test(int option)
{
	if(0 != (option & a))
		~~
	if(0 != (option & b))
		~~
}
Test(a | c); // 0101

Template<typename AAA>
Func(AAA a)
함수의 경우 사용시 인자추론이 동작한다. (호출시 자료형을 생략할 수 있다)
Func/*<int>*/(100)
Func/*<char>*/(c)
클래스의 경우 명시적으로 적어줘야한다. (메모리를 얼마나 잡아야하는지 모르기때문)
Class<int>
Class<char>

template <typename T>
class Tclass
{
	public:
	void Func();
	T value;
}
Tclass::Func() // 이경우 클래스의 자료형이 없어서 동작하지 않는다. Tclass<int>::Func()처럼 해줘야한다.
이거 안하려고 쓰는 문법이 템플릿 이므로 일반적으로 템플릿 클래스는 헤더에서 전부 구현한다.

가상함수
함수포인터배열을 가진다.(8바이트)
void(*Func[10])(); // 함수포인터배열
void(**ArrFunc)(); // 가상함수 테이블